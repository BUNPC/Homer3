
% When ever you change this function, then it is necessary to run
% procStreamGenHelp() from the matlab command line

function reg = procStreamRegRun()

reg = {

{
'@ hmrIntensityNormalized dod (d', ...
'dod = hmrIntensityNormalized( d )', ...
'UI NAME', ...
'Intensity_Normalized', ...
'INPUT', ...
'd - intensity data (#time points x #data channels)', ...
'OUTPUT', ...
'dod - the intensity divided by the mean'...
},

{
'@ hmrIntensity2OD dod (d', ...
'dod = hmrIntensity2OD( d )', ...
'UI NAME:', ...
'Intensity_to_OD ', ...
'Converts internsity (raw data) to optical density', ...
'INPUT', ...
'd - intensity data (#time points x #data channels', ...
'OUTPUT', ...
'dod - the change in optical density'...
},

{
'@ enPCAFilter #[dod,svs,nSV] (dod,SD,tIncMan nSV %0.2f 0', ...
'[yc, svs, nSV] = enPCAFilter( y, SD, tInc, nSV )', ...
'UI NAME:', ...
'PCA_Filter', ...
'[yc, svs, nSV] = enPCAFilter( y, SD, tInc, nSV )', ...
'Perform a PCA filter on the data matrix y. ', ...
'INPUT:', ...
'y: This is the data matrix where rows are time points. If y is wavelength', ...
'data, then the columns are channels as described in SD.MeasList. If', ...
'y is concentration data, then the third dimension is channels and the', ...
'second dimension indicates HbO and HbR.', ...
'SD: This is the source detector structure.', ...
'tInc: This is a vector of length number of time points and is 1 to', ...
'indicate that a time point is included in the analysis and 0 if it is to', ...
'be excluded. This is useful for ignoring periods of time with strong', ...
'artifacts.', ...
'nSV: This is the number of principle components to remove filter from the', ...
'data. This can be an integer to indicate the number of components to', ...
'remove. Or it can be a fraction less than 1 to indicate that enough', ...
'components should be removed to remove up to that fraction of the', ...
'variance in the data. If nSV is a single number it is applied to all', ...
'channels of data. This is useful for filtering motion artifacts. If it is', ...
'2 or more numbers, then it is applied to each wavelength or concentration', ...
'separately using the corresponding number.', ...
'OUTPUT:', ...
'yc: The filtered data matrix.', ...
'svs: The singuler value spectrum from the PCA.', ...
'nSV: This is the number of components filtered from the data.'...
},

{
'@ enPruneChannels SD (d,SD,tIncMan dRange %.0e_%.0e 0_1e7 SNRthresh %d 2 reset %d 0', ...
'SD = enPruneChannels(d,SD,tInc,dRange,SNRthresh,resetFlag)', ...
'UI NAME:', ...
'Prune_Channels', ...
'Prune channels from the measurement list if their signal is too weak, too', ...
'strong, or their standard deviation is too great. This function', ...
'updates SD.MeasListAct based on whether data ''d''', ...
'as specified by''dRange'' and ''SNRthresh''', ...
'INPUTS:', ...
'd - data (nTpts x nChannels )', ...
'SD - data structure describing the probe', ...
'dRange - if mean(d) < dRange(1) or > dRange(2) then it is excluded as an', ...
'active channel', ...
'SNRthresh - if mean(d)/std(d) < SNRthresh then it is excluded as an', ...
'active channel', ...
'OUTPUTS:', ...
'SD - data structure describing the probe', ...
'TO DO:', ...
'consider Conc as well as wavelength data'...
},

{
'@ hmrMotionArtifact tIncAuto (dod,t,SD,tIncMan tMotion %0.1f 0.5 tMask %0.1f 1 STDEVthresh %0.1f 50 AMPthresh %0.2f 5', ...
'tInc = hmrMotionArtifact(d, fs, SD, tIncMan, tMotion, tMask, STDEVthresh, AMPthresh)', ...
'UI NAME:   ', ...
'Motion_Artifacts', ...
'Identifies motion artifacts in an input data matrix d. If any active ', ...
'data channel exhibits a signal change greater than std_thresh or', ...
'amp_thresh, then a segment of data around that time point is marked as a', ...
'motion artifact.', ...
'INPUTS:', ...
'd: data matrix, timepoints x sd pairs', ...
'fs: sample frequency in Hz. You can send the time vector and fs will be', ...
'calculated', ...
'SD: Source Detector Structure. The active data channels are indicated in', ...
'SD.MeasListAct.', ...
'tIncMan: Data that has been manually excluded. 0-excluded. 1-included.', ...
'Vector same length as d.', ...
'tMotion: Check for signal change indicative of a motion artifact over', ...
'time range tMotion. Units of seconds. ', ...
'Typical value ranges from 0.1 to 0.5.', ...
'tMask: Mark data over +/- tMask seconds around the identified motion ', ...
'artifact as a motion artifact. Units of seconds. ', ...
'Typical value ranges from 0.5 to 1.', ...
'STDEVthresh: If the signal d for any given active channel changes by more', ...
'that stdev_thresh * stdev(d) over the time interval tMotion, then', ...
'this time point is marked as a motion artifact. The standard deviation is', ...
'determined for each channel independently.', ...
'Typical value ranges from 5 to 20. Use a value of 100 or greater if', ...
'you wish for this condition to not find motion artifacts.', ...
'AMPthresh: If the signal d for any given active channel changes by more', ...
'that amp_thresh over the time interval tMotion, then this time point', ...
'is marked as a motion artifact.', ...
'Typical value ranges from 0.01 to 0.3 for optical density units. Use', ...
'a value greater than 100 if you wish for this condition to not find', ...
'motion artifacts.', ...
'OUTPUTS:', ...
'tInc: a vector of length time points with 1''', ...
'and 0''', ...
'LOG:', ...
'K. Perdue', ...
'kperdue@nmr.mgh.harvard.edu', ...
'Sept. 23, 2010', ...
'Modified by DAB 3/17/2011 to not act on a single channel by default', ...
'DAB 4/20/2011 added tMotion and tMask and hard coded stdev option.', ...
'DAB 8/4/2011 added amp_thresh to work at same time as std_thresh', ...
'TO DO:', ...
'Consider tIncMan'...
},

{
'@ hmrMotionArtifactByChannel [tIncAuto,tIncChAuto] (dod,t,SD,tIncMan tMotion %0.1f 0.5 tMask %0.1f 1 STDEVthresh %0.1f 50 AMPthresh %0.2f 5', ...
'[tInc,tIncCh] = hmrMotionArtifactByChannel(d, fs, SD, tIncMan, tMotion, tMask, STDEVthresh, AMPthresh)', ...
'UI NAME:   ', ...
'Motion_Artifacts_By_Channel', ...
'Identifies motion artifacts in an input data matrix d. If any active ', ...
'data channel exhibits a signal change greater than std_thresh or', ...
'amp_thresh, then a segment of data around that time point is marked as a', ...
'motion artifact. The channel-wise motion artifacts are recorded in the', ...
'output matrix tIncCh. If any channel has a motion artifact, it is', ...
'indicated by the vector tInc.', ...
'INPUTS:', ...
'd: data matrix, timepoints x sd pairs', ...
'fs: sample frequency in Hz. You can send the time vector and fs will be', ...
'calculated', ...
'SD: Source Detector Structure. The active data channels are indicated in', ...
'SD.MeasListAct.', ...
'tIncMan: Data that has been manually excluded. 0-excluded. 1-included.', ...
'Vector same length as d.', ...
'tMotion: Check for signal change indicative of a motion artifact over', ...
'time range tMotion. Units of seconds.', ...
'tMask: Mark data over +/- tMask seconds around the identified motion ', ...
'artifact as a motion artifact. Units of seconds.', ...
'STDEVthresh: If the signal d for any given active channel changes by more', ...
'that stdev_thresh * stdev(d) over the time interval tMotion, then', ...
'this time point is marked as a motion artifact. The standard deviation is', ...
'determined for each channel independently.', ...
'AMPthresh: If the signal d for any given active channel changes by more', ...
'that amp_thresh over the time interval tMotion, then this time point', ...
'is marked as a motion artifact.', ...
'OUTPUTS:', ...
'tInc: a vector of length time points with 1''', ...
'and 0''', ...
'tIncCh: a matrix with #time points x #channels, with 1''', ...
'included and 0''', ...
'channel basis', ...
'LOG:', ...
'K. Perdue', ...
'kperdue@nmr.mgh.harvard.edu', ...
'Sept. 23, 2010', ...
'Modified by DAB 3/17/2011 to not act on a single channel by default', ...
'DAB 4/20/2011 added tMotion and tMask and hard coded stdev option.', ...
'DAB 8/4/2011 added amp_thresh to work at same time as std_thresh', ...
'TO DO:', ...
'Consider tIncMan'...
},

{
'@ hmrMotionCorrectWavelet [dod] (dod,SD iqr %.2f 1.5', ...
'function dodWavelet = hmrMotionCorrectWavelet(dod,SD,iqr)', ...
'UI NAME:', ...
'Wavelet_Motion_Correction', ...
'Perform a wavelet transformation of the dod data and computes the', ...
'distribution of the wavelet coefficients. It sets the coefficient', ...
'exceeding iqr times the interquartile range to zero, because these are probably due', ...
'to motion artifacts. ', ...
'The algorithm follows in part the procedure described by', ...
'Molavi et al.,Physiol Meas, 33, 259-270 (2012).', ...
'INPUTS:', ...
'dod:   delta_OD ', ...
'SD:    SD structure', ...
'iqr    parameter used to compute the statistics (iqr = 1.5 is 1.5 times the', ...
'interquartile range and is usually used to detect outliers). ', ...
'Increasing it, it will delete fewer coefficients.', ...
'If iqr<0 then this function is skipped.', ...
'OUTPUTS:', ...
'dodWavelet:  dod after wavelet motion correction, same', ...
'size as dod (Channels that are not in the active ml remain unchanged)', ...
'LOG:', ...
'Script by Behnam Molavi bmolavi@ece.ubc.ca adapted for Homer2 by RJC', ...
'modified 10/17/2012 by S. Brigadoi'...
},

{
'@ hmrMotionCorrectPCA #[dod,svsMotion,nSVMotion] (SD,dod,tIncAuto nSV %.2f .8', ...
'[dN,svs,nSV] = hmrMotionCorrectPCA( SD, d, tInc, nSV )', ...
'UI NAME:', ...
'PCA_Motion_Correction', ...
'This function uses PCA to filter only the segments of data identified as', ...
'a motion artifact. The motion artifacts are indicated in the tInc vector', ...
'by the value of 0.', ...
'INPUTS', ...
'SD:   Source Detector Structure. The active data channels are indicated in', ...
'SD.MeasListAct.', ...
'd:    data matrix, timepoints x sd pairs', ...
'tInc: a vector of length time points with 1''', ...
'and 0''', ...
'nSV: This is the number of principal components to remove from the data.', ...
'If this number is less than 1, then the filter removes the first n', ...
'components of the data that removes a fraction of the variance', ...
'up to nSV.', ...
'OUTPUTS', ...
'dN: This the the motion corrected data.', ...
'svs: the singular values of the PCA', ...
'nSV: number of singular values removed from the data.'...
},

{
'@ hmrMotionCorrectPCArecurse [dod,tIncAuto,svs,nSV,tIncAuto0] (dod,t,SD,tIncMan tMotion %0.1f 0.5 tMask %0.1f 1.0 STDEVthresh %0.1f 20.0 AMPthresh %0.2f 0.5 nSV %.2f 0.95 maxIter %d 5', ...
'[dN,tInc,dstd,svs,nSV,tInc0] = hmrMotionCorrectPCArecurse( d, fs, SD, tIncMan, tMotion, tMask, std_thresh, amp_thresh, nSV )', ...
'UI NAME', ...
'Motion_Correct_PCA_Recurse', ...
'Identified motion artifacts in an input data matrix d. If any active ', ...
'data channel exhibits a signal change greater than std_thresh or', ...
'amp_thresh, then a segment of data around that time point is marked as a', ...
'motion artifact.', ...
'INPUTS:', ...
'd: data matrix, timepoints x sd pairs', ...
'fs: sample frequency in Hz. You can send the time vector and fs will be', ...
'calculated', ...
'SD: Source Detector Structure. The active data channels are indicated in', ...
'SD.MeasListAct.', ...
'tIncMan: Data that has been manually excluded. 0-excluded. 1-included.', ...
'Vector same length as d.', ...
'tMotion: Check for signal change indicative of a motion artifact over', ...
'time range tMotion. Units of seconds.', ...
'tMask: Mark data over +/- tMask seconds around the identified motion ', ...
'artifact as a motion artifact. Units of seconds.', ...
'STDEVthresh: If the signal d for any given active channel changes by more', ...
'that stdev_thresh * stdev(d) over the time interval tMotion, then', ...
'this time point is marked as a motion artifact. The standard deviation is', ...
'determined for each channel independently.', ...
'AMPthresh: If the signal d for any given active channel changes by more', ...
'that amp_thresh over the time interval tMotion, then this time point', ...
'is marked as a motion artifact.', ...
'nSV: This is the number of principal components to remove from the data.', ...
'If this number is less than 1, then the filter removes the first n', ...
'components of the data that removes a fraction of the variance', ...
'up to nSV.', ...
'maxIter: Maximum number of iterations.', ...
'OUTPUTS:', ...
'dN: This is the the motion corrected data.', ...
'tInc: a vector of length time points with 1''', ...
'and 0''', ...
'artifacts', ...
'svs: the singular values of the PCA', ...
'nSV: number of singular values removed from the data.', ...
'tInc0: a vector of length time points with 1''', ...
'and 0''', ...
'artifacts'...
},

{
'@ hmrMotionCorrectSpline [dod] (dod,t,SD,tIncChAuto p %.2f .99', ...
'function dodSpline = hmrMotionCorrectSpline(dod, t, SD, tInc, p)', ...
'UI NAME:', ...
'Spline_Motion_Correction', ...
'dodSpline = hmrMotionCorrectSpline(dod, t, SD, tInc, p)', ...
'Perform a cubic spline correction of the motion artifacts identified in', ...
'tInc. The algorithm follows the procedure describe by', ...
'Scholkmann et al., Physiol. Meas. 31, 649-662 (2010).', ...
'INPUTS:', ...
'dod:   delta_OD', ...
't:     time vector', ...
'SD:    SD structure', ...
'tInc:  Matrix of included time points (1=included; 0=not included (movement)', ...
'The matrix is #time points x #channels and usually comes from', ...
'hmrMotionArtifactByChannel()', ...
'p:     Parameter p used in the spline interpolation', ...
'OUTPUTS:', ...
'dodSpline:  dod after spline interpolation correction, same size as dod', ...
'(Channels that are not in the active ml remain unchanged)', ...
'LOG:', ...
'created 01-26-2012, J. Selb', ...
'TO DO:'...
},

{
'@ hmrMotionCorrectCbsi [dc] (dc,SD flagSkip %d 0', ...
'function dcCbsi = hmrMotionCorrectCbsi(dc,SD,flagSkip)', ...
'UI NAME:', ...
'Cbsi_Motion_Correction', ...
'Perform a correlation-based signal improvement of the concentration', ...
'changes in order to correct for motion artifacts.  ', ...
'The algorithm follows the procedure described by', ...
'Cui et al.,NeuroImage, 49(4), 3039-46 (2010).', ...
'INPUTS:', ...
'dc:    Concentration changes (it works with HbO and HbR)', ...
'SD:    SD structure', ...
'flagSkip:  Skip this function if flagSkip=1. Otherwise execute function. ', ...
'Default is to execute function if this does not exist.', ...
'OUTPUTS:', ...
'dcSpline:  dc after correlation-based signal improvement correction, same', ...
'size as dc (Channels that are not in the active ml remain unchanged)', ...
'LOG:', ...
'created 10-17-2012, S. Brigadoi'...
},

{
'@ enStimRejection [s,tRangeStimReject] (t,s,tIncAuto,tIncMan tRange %0.1f_%0.1f -5_10', ...
'[s,tRange] = enStimRejection(t,s,tIncAuto,tIncMan,tRange)', ...
'UI NAME:', ...
'Stim_Exclude', ...
'Excludes stims that fall within the time points identified as ', ...
'motion artifacts from HRF calculation.', ...
'INPUT:', ...
't:        the time vector (#time points x 1)', ...
's:        s matrix (#time points x #conditions) containing 1 for ', ...
'each time point and condition that has a stimulus and ', ...
'zeros otherwise.', ...
'tIncAuto: time points (#time points x 1) identified as motion ', ...
'artifacts by processing stream.', ...
'tIncMan:  time points (#time points x 1) identified as motion ', ...
'artifacts by user.', ...
'tRange:   an array of 2 numbers [t1 t2] specifying how many ', ...
'seconds surrounding motion artifacts, tIncMan and tIncAuto, ', ...
'to consider as excluded data and therefore exclude any stimuli ', ...
'which fall within those buffers.', ...
'Typically values are t1=-2 and t2 equal to the stimulus', ...
'duration.', ...
'OUTPUT:', ...
's:        s matrix (#time points x #conditions) containing 1 for ', ...
'each time point and condition that has a stimulus that is ', ...
'included in the HRF calculation, -1 for a stimulus that is ', ...
'excluded automatically in the processing stream, -2 ', ...
'for each stimulus excluded by a manually set patch and ', ...
'zeros otherwise.', ...
'tRange:   same tRange array as in the input'...
},

{
'@ hmrBandpassFilt dod (dod,t hpf %0.3f 0 lpf %0.2f 3', ...
'y2 = hmrBandpassFilt( y, fs, hpf, lpf )', ...
'UI NAME:', ...
'Bandpass_Filter', ...
'y2 = hmrBandpassFilt( y, fs, hpf, lpf )', ...
'Perform a bandpass filter', ...
'INPUT:', ...
'y - data to filter #time points x #channels of data', ...
'fs - sample frequency (Hz). If length(fs)>1 then this is assumed to be a time', ...
'vector from which fs is estimated', ...
'hpf - high pass filter frequency (Hz)', ...
'Typical value is 0 to 0.02.', ...
'lpf - low pass filter frequency (Hz)', ...
'Typical value is 0.5 to 3.', ...
'OUTPUT:', ...
'y2 - filtered data'...
},

{
'@ hmrBandpassFiltConc dc (dc,t hpf %0.3f 0 lpf %0.2f 3', ...
''...
},

{
'@ enPCAFilter #[dod,svs_dod,nSV_dod] (dod,SD,tIncMan nSV %0.2f_%0.2f 0_0', ...
'[yc, svs, nSV] = enPCAFilter( y, SD, tInc, nSV )', ...
'UI NAME:', ...
'PCA_Filter', ...
'[yc, svs, nSV] = enPCAFilter( y, SD, tInc, nSV )', ...
'Perform a PCA filter on the data matrix y. ', ...
'INPUT:', ...
'y: This is the data matrix where rows are time points. If y is wavelength', ...
'data, then the columns are channels as described in SD.MeasList. If', ...
'y is concentration data, then the third dimension is channels and the', ...
'second dimension indicates HbO and HbR.', ...
'SD: This is the source detector structure.', ...
'tInc: This is a vector of length number of time points and is 1 to', ...
'indicate that a time point is included in the analysis and 0 if it is to', ...
'be excluded. This is useful for ignoring periods of time with strong', ...
'artifacts.', ...
'nSV: This is the number of principle components to remove filter from the', ...
'data. This can be an integer to indicate the number of components to', ...
'remove. Or it can be a fraction less than 1 to indicate that enough', ...
'components should be removed to remove up to that fraction of the', ...
'variance in the data. If nSV is a single number it is applied to all', ...
'channels of data. This is useful for filtering motion artifacts. If it is', ...
'2 or more numbers, then it is applied to each wavelength or concentration', ...
'separately using the corresponding number.', ...
'OUTPUT:', ...
'yc: The filtered data matrix.', ...
'svs: The singuler value spectrum from the PCA.', ...
'nSV: This is the number of components filtered from the data.'...
},

{
'@ hmrOD2Conc dc (dod,SD ppf %0.1f_%0.1f 6_6', ...
'dc = hmrOD2Conc( dod, SD, ppf )', ...
'UI NAME:', ...
'OD_to_Conc', ...
'dc = hmrOD2Conc( dod, SD, ppf )', ...
'Convert OD to concentrations', ...
'INPUTS:', ...
'dod: the change in OD (#time points x #channels)', ...
'SD:  the SD structure', ...
'ppf: partial pathlength factors for each wavelength. If there are 2', ...
'wavelengths of data, then this is a vector ot 2 elements.', ...
'Typical value is ~6 for each wavelength if the absorption change is ', ...
'uniform over the volume of tissue measured. To approximate the', ...
'partial volume effect of a small localized absorption change within', ...
'an adult human head, this value could be as small as 0.1.', ...
'OUTPUTS:', ...
'dc: the concentration data (#time points x 3 x #SD pairs', ...
'3 concentrations are returned (HbO, HbR, HbT)'...
},

{
'@ hmrConc2OD dod (dc,SD ppf %0.1f_%0.1f 6_6', ...
'dod = hmrConc2OD( dc, SD, ppf )', ...
'UI NAME:', ...
'Conc_to_OD', ...
'dod = hmrConc2OD( dc, SD, ppf )', ...
'Convert concentrations to OD', ...
'INPUTS:', ...
'dc: the concentration data (#time points x 3 x #SD pairs', ...
'3 concentrations are returned (HbO, HbR, HbT)', ...
'SD:  the SD structure', ...
'ppf: partial pathlength factors for each wavelength. If there are 2', ...
'wavelengths of data, then this is a vector ot 2 elements.', ...
'Typical value is ~6 for each wavelength if the absorption change is ', ...
'uniform over the volume of tissue measured. To approximate the', ...
'partial volume effect of a small localized absorption change within', ...
'an adult human head, this value could be as small as 0.1.', ...
'OUTPUTS:', ...
'dod: the change in OD (#time points x #channels)'...
},

{
'@ enPCAFilter #[dc,svs,nSV] (dc,SD,tIncMan nSV %0.1f_%0.1f 0_0', ...
'[yc, svs, nSV] = enPCAFilter( y, SD, tInc, nSV )', ...
'UI NAME:', ...
'PCA_Filter', ...
'[yc, svs, nSV] = enPCAFilter( y, SD, tInc, nSV )', ...
'Perform a PCA filter on the data matrix y. ', ...
'INPUT:', ...
'y: This is the data matrix where rows are time points. If y is wavelength', ...
'data, then the columns are channels as described in SD.MeasList. If', ...
'y is concentration data, then the third dimension is channels and the', ...
'second dimension indicates HbO and HbR.', ...
'SD: This is the source detector structure.', ...
'tInc: This is a vector of length number of time points and is 1 to', ...
'indicate that a time point is included in the analysis and 0 if it is to', ...
'be excluded. This is useful for ignoring periods of time with strong', ...
'artifacts.', ...
'nSV: This is the number of principle components to remove filter from the', ...
'data. This can be an integer to indicate the number of components to', ...
'remove. Or it can be a fraction less than 1 to indicate that enough', ...
'components should be removed to remove up to that fraction of the', ...
'variance in the data. If nSV is a single number it is applied to all', ...
'channels of data. This is useful for filtering motion artifacts. If it is', ...
'2 or more numbers, then it is applied to each wavelength or concentration', ...
'separately using the corresponding number.', ...
'OUTPUT:', ...
'yc: The filtered data matrix.', ...
'svs: The singuler value spectrum from the PCA.', ...
'nSV: This is the number of components filtered from the data.'...
},

{
'@ enCrossCorrelation #[cc,ml,cc_thresh] (SD,dc cc_thresh %0.2f 0.4', ...
'[cc,ml,cc_thresh] = enCrossCorrelation( SD, dc0, cc_thresh )', ...
'UI NAME:', ...
'Cross_Correlation'...
},

{
'@ enAdaptiveFilteringSS [dc,iNearestSS] (SD,t,dc nTimePts %d 1 Step_Size  %0.1e 1e-4', ...
'[dc,iNearestSS] = enAdaptiveFilteringSS(SD,t,dc,M,mu)', ...
'UI NAME:', ...
'Adaptive_Filtering_ShortSep'...
},

{
'@ enStimIncData_varargin [s,nFuncParam0,funcParam0,funcParamFormat0,funcParamVal0] (s,t,userdata *', ...
'[s,nFuncParam,funcParam,funcParamFormat,funcParamVal] = enStimIncData_varargin(s,t,userdata,varargin)', ...
'UI NAME:', ...
'Stim_Include_UserDefVar', ...
'Excludes stims based on user-defined variables', ...
'INPUT:', ...
's:         s matrix (#time points x #conditions) containing 1 for ', ...
'each time point and condition that has a stimulus and ', ...
'zeros otherwise.', ...
't:         the time vector (#time points x 1)', ...
'userdata:  table of user-defined variable values based on which stims can ', ...
'be excluded.  (# of stims  x  # of user defined variables)', ...
'varargin:  ranges for each of the user defined variables from userdata.', ...
'OUTPUT:', ...
's               : s matrix (#time points x #conditions) ', ...
'nFuncParam      : # of user-defined variables from userdata used ', ...
'when function is first added to processing stream. ', ...
'funcParam       : Names of user-defined variables from userdata', ...
'when function is first added to processing stream. ', ...
'funcParamFormat : format of user-defined variables from userdata', ...
'when function is first added to processing stream. ', ...
'funcParamVal    : values of user-defined variables from userdata', ...
'when function is first added to processing stream. '...
},

{
'@ hmrCreateAuxRegressor Aaux (aux,t param %d_%.3f_%.1f 1_0_1', ...
''...
},

{
'@ hmrBlockAvg [dcAvg,dcAvgStd,tHRF,nTrials,dcSum2] (dc,s,t trange %0.1f_%0.1f -2_20', ...
'[yavg, ystd, tHRF, nTrials, ysum2, yTrials] = hmrBlockAvg( y, s, t, trange )', ...
'UI NAME:', ...
'Block_Average', ...
'Calculate the block average given the stimulation conditions in s over', ...
'the time range trange. The baseline of the average is set to zero by', ...
'subtracting the mean of the average for t<0. If a stimulus occurs too', ...
'close to the start or end of the data such that trange extends outside of', ...
'the data range, then the trial is excluded from the average.', ...
'INPUTS:', ...
'y: this is the data wavelength #time points x #channels', ...
'concentration data is #time points x [HbO/HbR/HbT] x #channels', ...
's: stimulation vector (# time points x #conditions)=1 at stim onset otherwise =0', ...
't: time vector corresponding with y and s', ...
'trange: defines the range for the block average [tPre tPost]', ...
'OUTPUTS:', ...
'yavg: the averaged results', ...
'ystd: the standard deviation across trials', ...
'tHRF: the time vector', ...
'nTrials: the number of trials averaged for each condition', ...
'yTrials: a structure containing the individual trial responses'...
},

{
'@ hmrBlockAvg [dodAvg,dodAvgStd,tHRF,nTrials,dodSum2] (dod,s,t trange %0.1f_%0.1f -2_20'...
'[yavg, ystd, tHRF, nTrials, ysum2, yTrials] = hmrBlockAvg( y, s, t, trange )', ...
'UI NAME:', ...
'Block_Average', ...
'Calculate the block average given the stimulation conditions in s over', ...
'the time range trange. The baseline of the average is set to zero by', ...
'subtracting the mean of the average for t<0. If a stimulus occurs too', ...
'close to the start or end of the data such that trange extends outside of', ...
'the data range, then the trial is excluded from the average.', ...
'INPUTS:', ...
'y: this is the data wavelength #time points x #channels', ...
'concentration data is #time points x [HbO/HbR/HbT] x #channels', ...
's: stimulation vector (# time points x #conditions)=1 at stim onset otherwise =0', ...
't: time vector corresponding with y and s', ...
'trange: defines the range for the block average [tPre tPost]', ...
'OUTPUTS:', ...
'yavg: the averaged results', ...
'ystd: the standard deviation across trials', ...
'tHRF: the time vector', ...
'nTrials: the number of trials averaged for each condition', ...
'yTrials: a structure containing the individual trial responses'...
},

{
'@ hmrBlockAvg [dcAvg,dcAvgStd,tHRF,nTrials,dcSum2,dcTrials] (dc,s,t trange %0.1f_%0.1f -2_20', ...
'[yavg, ystd, tHRF, nTrials, ysum2, yTrials] = hmrBlockAvg( y, s, t, trange )', ...
'UI NAME:', ...
'Block_Average', ...
'Calculate the block average given the stimulation conditions in s over', ...
'the time range trange. The baseline of the average is set to zero by', ...
'subtracting the mean of the average for t<0. If a stimulus occurs too', ...
'close to the start or end of the data such that trange extends outside of', ...
'the data range, then the trial is excluded from the average.', ...
'INPUTS:', ...
'y: this is the data wavelength #time points x #channels', ...
'concentration data is #time points x [HbO/HbR/HbT] x #channels', ...
's: stimulation vector (# time points x #conditions)=1 at stim onset otherwise =0', ...
't: time vector corresponding with y and s', ...
'trange: defines the range for the block average [tPre tPost]', ...
'OUTPUTS:', ...
'yavg: the averaged results', ...
'ystd: the standard deviation across trials', ...
'tHRF: the time vector', ...
'nTrials: the number of trials averaged for each condition', ...
'yTrials: a structure containing the individual trial responses'...
},

{
'@ plotTrials #[dcTrials,tHRF,SD] (dcTrials,tHRF,SD', ...
''...
},

{
'@ hmrFindHrfOutlier [s,dcAvg,dcAvgStd,nTrials,dcSum2,dcTrials] (s,tHRF,dcTrials tRange %0.1f_%0.1f 4_8 stdThresh %.1f 3 minNtrials %d 0', ...
'[s,yAvg,yStd,nTrials,ysum2,yTrials] = hmrFindHrfOutlier( s, tHRF, yTrials, tRange, stdThresh, minNtrials )', ...
'UI NAME:', ...
'Find_Outlier_Trials', ...
'Find trials that are outliers with respect to the average HRF. Remove', ...
'those trials from the stimulus vector s and reaverage the results. The', ...
'mean and standard deviation of the trials are found over the time range', ...
'specified by tRange. Outliers are trials with a mean deviating more', ...
'than stdThresh standard deviations from the mean.', ...
'INPUTS:', ...
's: The stimulus vector', ...
'tHRF: The time vector for the HRF. This is generally returned with the', ...
'HRF from hmrBlockAvg() or comparable functions.', ...
'yTrials: This structure contains the response to each trial for each', ...
'stimulus condition. This structure is obtained from hmrBlockAvg().', ...
'tRange: The time range over which the mean is estimated.', ...
'stdThresh: The number of standard deviations that a trial must deviate', ...
'to be considered an outlier.', ...
'minNtrials: Only remove outliers if number of trials for the given ', ...
'condition is equal to our greater than this limit.', ...
'OUTPUTS:', ...
's: the stimulus vector revised for any trials removed as outliers', ...
'yAvg: the averaged results', ...
'yStd: the standard deviation across trials', ...
'nTrials: the number of trials averaged for each condition', ...
'ysum2: A variable that enables calculation of the standard deviation', ...
'across multiple runs for a single subject.', ...
'yTrials: a structure containing the individual trial responses', ...
'TO DO:', ...
'This function assumes the data is hemoglobin concentrations. The code', ...
'should be modified to handle either wavelength data or hemoglobin', ...
'concentration data.'...
},

{
'@ hmrRegressors [dcResid,dcAvg,tHRF,nTrials] (dc,s,t trange %0.1f_%0.1f -2_10', ...
'function [yresid, yhrf, tHRF, nTrials] = hmrRegressors(yo, yreg, t, trange, nStim )', ...
'UI NAME:', ...
'Regressors', ...
'Calculate the impulse response to different regressors', ...
'INPUT', ...
'yo - this is the concentration data (#time points x [HbO/HbR/HbT] x', ...
'#channels)', ...
'yreg - these are the regressors (#time points x #regressors)', ...
'the first nStim columns are assumed to be stimulus marks for each ', ...
'of nStim independent stimulus conditions', ...
't - the time vector (#time points x 1)', ...
'trange - the time range for the impulse response function [tpre tpost]', ...
'nStim - number of different stimulus conditions presented in yreg', ...
'This is optional. If not included then nStim = size(yreg,2)', ...
'OUTPUT', ...
'yresid - residual of the regressor fit to the data (#time points x', ...
'[HbO/Hbr/HbT] x #channels)', ...
'yhrf - impulse response to the stimuli (#time points x [HbO/Hbr/HbT] x', ...
'#channels x #nStim) ', ...
'tHRF - This is the time vector for the estimted HRF', ...
'nTrials - number of trials for each stim condition in yreg'...
},

{
'@ hmrDeconvTB_3rd [dcAvg,dcAvgStd,tHRF,nTrials,dcSum2] (dc,s,t,Aaux trange %0.1f_%0.1f -2_10 gstd %0.1f 1 gms %0.1f 1', ...
'[yavg, yavgstd, tHRF, nTrials, ysum2] = hmrDeconvTB_3rd(y, s, t, Aaux, trange, gstd, gms)', ...
'UI NAME: ', ...
'GLM_HRF_Drift', ...
'This script estimates the HRF with a set a temporal basis without any', ...
'preprocessing but uses a 3rd order polynomial drift regressor', ...
'LOG:', ...
'created 1-14-2011 L. Gagnon'...
},

{
'@ hmrDeconvTB_SS3rd [dodAvg,dodAvgStd,tHRF,nTrials,dod,dodResid,dodSum2] (dod,s,t,SD,Aaux trange %0.1f_%0.1f -2_10 gstd %0.1f 1 gms %0.1f 1 rhoSD_ssThresh %0.1f 15 ', ...
'[yavg, yavgstd, tHRF, nTrials, ysum2] = hmrDeconvTB_SS3rd(y, s, t, SD, Aaux, trange, gstd, gms, rhoSD_ssThresh)', ...
'UI NAME: ', ...
'GLM_HRF_ShortSep_Drift', ...
'This script estimates the HRF with a set a temporal basis functions,', ...
'regresses the nearest short separation measurement,', ...
'and uses a 3rd order polynomial regressor.', ...
'The command line function call is', ...
'[yavg, yavgstd, tHRF, nTrials, ysum2] = hmrDeconvTB_SS3rd(y, s, t, SD, Aaux, trange, gstd, gms, rhoSD_ssThresh)', ...
'INPUTS:', ...
'y - this is the data wavelength #time points x #channels', ...
'concentration data is #time points x [HbO/HbR/HbT] x #channels', ...
's - stimulation vector (# time points x #conditions)=1 at stim onset otherwise =0', ...
't - time vector corresponding with y and s', ...
'SD - source detector stucture (units should be consistent with rhoSD_ssThresh)', ...
'trange - defines the range for the block average [tPre tPost]', ...
'gstd - std for gaussian shape temporal basis function (sec)', ...
'gms - mean for gaussian shape temporal basis function (sec)', ...
'rhoSD_ssThresh: max distance for a short separation measurement (cm)', ...
'OUTPUTS:', ...
'yavg - the averaged results', ...
'ystd - the standard deviation across trials', ...
'tHRF - the time vector', ...
'nTrials - the number of trials averaged for each condition', ...
'LOG', ...
'created 1-14-2011 L. Gagnon'...
},

{
'@ hmrDeconvTB_SS3rd [dcAvg,dcAvgStd,tHRF,nTrials,dc,dcResid,dcSum2] (dc,s,t,SD,Aaux trange %0.1f_%0.1f -2_10 gstd %0.1f 1 gms %0.1f 1 rhoSD_ssThresh %0.1f 15 ', ...
'[yavg, yavgstd, tHRF, nTrials, ysum2] = hmrDeconvTB_SS3rd(y, s, t, SD, Aaux, trange, gstd, gms, rhoSD_ssThresh)', ...
'UI NAME: ', ...
'GLM_HRF_ShortSep_Drift', ...
'This script estimates the HRF with a set a temporal basis functions,', ...
'regresses the nearest short separation measurement,', ...
'and uses a 3rd order polynomial regressor.', ...
'The command line function call is', ...
'[yavg, yavgstd, tHRF, nTrials, ysum2] = hmrDeconvTB_SS3rd(y, s, t, SD, Aaux, trange, gstd, gms, rhoSD_ssThresh)', ...
'INPUTS:', ...
'y - this is the data wavelength #time points x #channels', ...
'concentration data is #time points x [HbO/HbR/HbT] x #channels', ...
's - stimulation vector (# time points x #conditions)=1 at stim onset otherwise =0', ...
't - time vector corresponding with y and s', ...
'SD - source detector stucture (units should be consistent with rhoSD_ssThresh)', ...
'trange - defines the range for the block average [tPre tPost]', ...
'gstd - std for gaussian shape temporal basis function (sec)', ...
'gms - mean for gaussian shape temporal basis function (sec)', ...
'rhoSD_ssThresh: max distance for a short separation measurement (cm)', ...
'OUTPUTS:', ...
'yavg - the averaged results', ...
'ystd - the standard deviation across trials', ...
'tHRF - the time vector', ...
'nTrials - the number of trials averaged for each condition', ...
'LOG', ...
'created 1-14-2011 L. Gagnon'...
},

{
'@ hmrDeconvTB_SS3rd_Highest [dcAvg,dcAvgStd,tHRF,nTrials,dcSum2] (dc,s,t,SD,cc,Aaux trange %0.1f_%0.1f -2_10 gstd %0.1f 1 gms %0.1f 1 rhoSD_ssThresh %0.1f 15', ...
'[yavg, yavgstd, tHRF, nTrials, ysum2] = hmrDeconvTB_SS3rd_Highest(y, s, t, SD, cc, Aaux, trange, gstd, gms, rhoSD_ssThresh)', ...
'UI NAME:  ', ...
'Block_Avg_Short_Sep_Highest  ', ...
'This script estimates the HRF with a set a temporal basis without any  ', ...
'preprocessing but uses a 3rd order polynomial regressor. Also it finds short separations with highest correlation.  ', ...
'INPUTS:  ', ...
'y: this is the data wavelength #time points x #channels ', ...
'concentration data is #time points x [HbO/HbR/HbT] x #channels  ', ...
's: stimulation vector (# time points x #conditions)=1 at stim onset otherwise =0  ', ...
't: time vector corresponding with y and s .', ...
'SD: source detector stucture (units should be consistent with rhoSD_ssThresh)  ', ...
'trange: defines the range for the block average [tPre tPost]  ', ...
'gstd: std for gaussian shape temporal basis function (sec)  ', ...
'gms: mean for gaussian shape temporal basis function (sec)  ', ...
'rhoSD_ssThresh: max distance for a short separation measurement (cm)  ', ...
'OUTPUTS:  ', ...
'yavg: the averaged results  ', ...
'ystd: the standard deviation across trials  ', ...
'tHRF: the time vector  ', ...
'nTrials: the number of trials averaged for each condition ', ...
'LOG ', ...
'created 1-14-2011 L. Gagnon'...
},

{
'@ hmrDeconv_SS [dc] (dc,t,SD', ...
''...
},

{
'@ hmrImageHrfMeanTwin [dodAvgImg] (dodAvg,tHRF trange %0.1f_%0.1f 5_10', ...
''...
},

{
'@ hmrImageHrfMeanTwin [dcAvgImg] (dcAvg,tHRF trange %0.1f_%0.1f 5_10', ...
''...
},

{
'@ hmrImageRecon img (SD,dodAvgImg,dodResid alpha %.1e 1e-3', ...
''...
}

};
